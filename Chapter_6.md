# Chapter 6: Hardware Interrupt Handling in the Linux Kernel

## Introduction
Modern operating systems must respond quickly and efficiently to events generated by hardware devices. These events—such as a key press, network packet arrival, or completed disk operation—are communicated to the CPU via **hardware interrupts**.  

The Linux kernel implements a sophisticated interrupt handling mechanism that ensures minimal latency, high throughput, and system stability.  

This chapter provides a detailed walkthrough of the **lifecycle of a hardware interrupt**, from the moment it is triggered by a device to when the system resumes its previous execution context. Each stage has specific responsibilities and constraints.


## 6.1 Interrupt Generation by Hardware Devices
- A hardware device detects an event requiring CPU attention.  
- It sends an **electrical signal** on its assigned IRQ (Interrupt Request) line.  
- This signal is routed to the system’s **Interrupt Controller** (PIC or APIC).  


## 6.2 Role of the Interrupt Controller
The interrupt controller:
- Identifies the source of the interrupt.  
- Determines its priority relative to other pending interrupts.  
- Forwards the interrupt to the CPU.  

> High-priority interrupts are serviced promptly, while lower-priority ones may be delayed or masked.


## 6.3 CPU Response and Context Saving
Upon receiving the interrupt signal:
- CPU pauses its current execution.  
- Saves the current context (registers, program counter, stack pointer).  
- Disables further interrupts (or selectively masks them).  
- Consults the **Interrupt Descriptor Table (IDT)** to locate the correct **Interrupt Service Routine (ISR)**.  

### What If Another Interrupt Occurs?
- If interrupts are enabled and the new interrupt has higher priority, it can **preempt** the current handler.  
- If interrupts are disabled, the new interrupt is **delayed** until they are re-enabled.  



## 6.4 Execution of the Top-Half Handler
The **top-half handler (ISR)** is registered by the device driver using `request_irq()` and executes in **interrupt context** (non-preemptible, cannot sleep).  

**Responsibilities:**
- Acknowledge and clear the interrupt at device and controller levels.  
- Perform minimal, time-critical operations (e.g., reading device status).  
- Schedule a **bottom-half handler** for deferred processing.  

### Handling Other Interrupts
- Another interrupt may **preempt** the top-half if allowed.  
- Otherwise, it is queued or delayed.  


## 6.5 Bottom-Half Handling: Deferred Work
To offload non-urgent tasks, Linux uses **bottom-half mechanisms** that run in a schedulable context.  

**Types of Bottom-Half Mechanisms:**
| Mechanism | Context       | Preemptible | Use Case                           |
|------------|---------------|------------|------------------------------------|
| Soft IRQ   | Interrupt     | Partially  | High-performance networking/block I/O |
| Tasklet    | Interrupt     | No         | Lightweight deferred work (deprecated) |
| Workqueue | Process       | Yes        | Complex or blocking operations      |

**Responsibilities:**
- Process data collected by the top-half.  
- Interact with kernel subsystems.  
- Wake up user-space processes or kernel threads waiting for the event.  

**Interrupts During Bottom-Half:**
- New interrupts can preempt the bottom-half since it runs in normal kernel context.  
- After handling, the bottom-half resumes.  


## 6.6 Interaction with Kernel Subsystems
The bottom-half often interfaces with:
- **Network stack** → deliver packets to sockets.  
- **Block layer** → complete disk I/O operations.  
- **Input subsystem** → forward keystrokes or mouse events.  

These subsystems may:
- Update kernel data structures.  
- Notify user-space applications.  
- Trigger additional kernel events.  


## 6.7 Returning to the Previous Context
After bottom-half and subsystem processing:
- Kernel restores the previously saved CPU context.  
- CPU resumes execution of the interrupted task:  
  - User-space process  
  - Kernel thread  
  - Another interrupt handler (nested interrupts)  


## 6.8 Summary
Linux divides interrupt handling into **top-half** (ISR) and **bottom-half** (deferred work) for efficiency and modularity:  
- **Top-half:** Handles critical tasks immediately.  
- **Bottom-half:** Performs complex processing in safe, schedulable contexts.  

This structure allows Linux to scale across hardware platforms, from embedded systems to high-performance servers.  


### Key Characteristics of Bottom-Half Mechanisms

| Feature       | Soft IRQ       | Tasklet                      | Workqueue                    |
|---------------|---------------|------------------------------|-------------------------------|
| Context       | Interrupt     | Interrupt                    | Process                       |
| Can Sleep     | ❌            | ❌                            | ✅                             |
| Preemptible   | Partially     | No                           | Yes                           |
| Use Case      | High-performance/ High-frequency interrupts | Lightweight deferred tasks | Complex/blocking work /Deferred tasks needing blocking        |

## 6.9 Hardware Interrupt Lifecycle Diagram
```mermaid
flowchart TD
    A["Hardware Device Event"] --> B["Send IRQ Signal"]
    B --> C["Interrupt Controller (PIC/APIC)"]
    C --> D["CPU Receives Interrupt"]
    D --> E["Save CPU Context & Disable/Mask Interrupts"]
    E --> F["Top-Half Handler (ISR)"]
    F --> G["Schedule Bottom-Half for Deferred Work"]
    G --> H["Bottom-Half Handler: Soft IRQ / Tasklet / Workqueue"]
    H --> I["Interact with Kernel Subsystems"]
    I --> J["Network Stack / Block Layer / Input Subsystem"]
    J --> K["Restore CPU Context"]
    K --> L["Resume Interrupted Task"]
```

## 6.10 Enhanced Hardware Interrupt Lifecycle (Parallel Tracks)

```mermaid
flowchart LR
    %% Define parallel tracks
    subgraph Device ["Hardware Device"]
        A["Device Event / IRQ"]
    end

    subgraph CPU ["CPU & Top-Half"]
        B["Interrupt Controller (PIC/APIC)"]
        C["CPU Receives Interrupt"]
        D["Save Context & Disable/Mask Interrupts"]
        E["Top-Half Handler (ISR)"]
    end

    subgraph Kernel ["Bottom-Half & Subsystems"]
        F["Schedule Bottom-Half"]
        G["Bottom-Half Handler: Soft IRQ / Tasklet / Workqueue"]
        H["Interact with Kernel Subsystems"]
        I["Network Stack / Block Layer / Input Subsystem"]
    end

    subgraph Resume ["Return to Previous Task"]
        J["Restore CPU Context"]
        K["Resume Interrupted Task"]
    end

    %% Connections
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I --> J
    J --> K
```



## 6.11 Code example for SoftIRQ, Tasklet and Workqueue:
 - SoftIRQ: Low-level deferred execution, runs in interrupt context, fast, cannot sleep.
 - Tasklet: Built on top of SoftIRQ, simpler API, still cannot sleep, runs in interrupt context.
 - Workqueue: Runs in process context, can sleep, used for deferred work that may need blocking operations.

### 1️⃣ SoftIRQ Example
```c 
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>

static void my_softirq_handler(struct softirq_action *h)
{
    printk(KERN_INFO "SoftIRQ executed\n");
}

static int __init my_module_init(void)
{
    open_softirq(42, my_softirq_handler); // register softirq on vector 42
    printk(KERN_INFO "SoftIRQ registered\n");

    raise_softirq(42); // trigger it
    return 0;
}

static void __exit my_module_exit(void)
{
    printk(KERN_INFO "Module exiting\n");
}

module_init(my_module_init);
module_exit(my_module_exit);
MODULE_LICENSE("GPL");
```
### 2️⃣ Tasklet Example
```c
#include <linux/module.h>
#include <linux/interrupt.h>

static void my_tasklet_func(unsigned long data);

DECLARE_TASKLET(my_tasklet, my_tasklet_func, 0);

static void my_tasklet_func(unsigned long data)
{
    printk(KERN_INFO "Tasklet executed\n");
}

static int __init my_module_init(void)
{
    tasklet_schedule(&my_tasklet); // schedule the tasklet
    printk(KERN_INFO "Tasklet scheduled\n");
    return 0;
}

static void __exit my_module_exit(void)
{
    tasklet_kill(&my_tasklet); // ensure tasklet is finished
    printk(KERN_INFO "Module exiting\n");
}

module_init(my_module_init);
module_exit(my_module_exit);
MODULE_LICENSE("GPL");
```

### 3️⃣ Workqueue Example
```c
#include <linux/module.h>
#include <linux/workqueue.h>

static struct workqueue_struct *my_wq;
static struct work_struct my_work;

static void my_work_func(struct work_struct *work)
{
    printk(KERN_INFO "Workqueue executed\n");
}

static int __init my_module_init(void)
{
    my_wq = create_singlethread_workqueue("my_wq");
    if (!my_wq)
        return -ENOMEM;

    INIT_WORK(&my_work, my_work_func);
    queue_work(my_wq, &my_work); // queue work
    printk(KERN_INFO "Work queued\n");

    return 0;
}

static void __exit my_module_exit(void)
{
    flush_workqueue(my_wq);
    destroy_workqueue(my_wq);
    printk(KERN_INFO "Module exiting\n");
}

module_init(my_module_init);
module_exit(my_module_exit);
MODULE_LICENSE("GPL");
```
# Note

```mermaid
flowchart TD
    A["Hardware Interrupt"] --> B["ISR (Top Half)"]
    B --> C["SoftIRQ Scheduled"]
    C --> D["SoftIRQ Handler\n(Interrupt Context, Cannot Sleep)"]
    D --> E["Tasklet Scheduled?"]
    E -- Yes --> F["Tasklet Executes\n(Interrupt Context, Cannot Sleep)"]
    E -- No --> G["Workqueue Scheduled?"]
    F --> G
    G -- Yes --> H["Workqueue Executes\n(Process Context, Can Sleep)"]
    G -- No --> I["Deferred Work Done"]
    H --> I

```